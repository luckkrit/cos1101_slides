---
title: Computer Organization
---
# Computer Organization 

---

# Three subsystems in Computer

<div class="flex gap-3">
<div class="text-black text-xl">
มองเป็น hardware แบ่งเป็น 3 ส่วนสำคัญ

1. CPU
2. Main memory
3. I/O
</div>


<img class="w-96 mx-auto" src="/images/chapter5/three_sub_systems.png" />
</div>

---
layout: cover
---

# 1. CPU

---

# CPU

- **CPU คือ "Central Processing Unit"** หรือ หน่วยประมวลผลกลาง 
ซึ่งเป็นส่วนหนึ่งของคอมพิวเตอร์ที่ทำหน้าที่ประมวลผลข้อมูลและคำสั่งต่าง ๆ ที่เข้ามา 
นั่นคือสมองหลักของระบบคอมพิวเตอร์ที่ควบคุมการทำงานของเครื่องคอมพิวเตอร์ทั้งหมด

<img class="w-96 mx-auto" src="/images/chapter5/free-cpu-vector.png" />


---

# Outlines


- **CPU (Central Processing Unit)** มีหลายองค์ประกอบที่ทำให้สามารถทำงานและประมวลผลข้อมูลได้ 

- องค์ประกอบหลักของ CPU ประกอบด้วย:

    **1. Arithmetic Logic Unit (ALU) (หน่วยคณิตศาสตร์และตรรกะ):** ดำเนินการคำนวณทางคณิตศาสตร์และตรรกะต่าง ๆ ภายใน CPU.

    **2. Control Unit (หน่วยควบคุม):** ดูแลควบคุมการทำงานของ CPU โดยการอ่านคำสั่ง, ตรวจสอบเงื่อนไข, และควบคุมการทำงานของอื่น ๆ.

    **3. Registers (รีจิสเตอร์):** คือ หน่วยความจำขนาดเล็กความเร็วสูงที่อยู่ภายในหน่วยประมวลผลกลาง (CPU) ทำหน้าที่เก็บข้อมูลชั่วคราวที่ CPU กำลังใช้งานอยู่ เช่น คำสั่ง ตัวเลข หรือที่อยู่ความจำต่างๆ


---

# ALU

- ALU

    **1. Data Register:** เก็บข้อมูลที่ใช้ในการคำนวณ

    **2. Instruction Register (IR):** เก็บคำสั่งที่กำลังถูกประมวลผล เก็บคำสั่งที่กำลังจะทำงาน.

    **3. Program Counter (PC):** เก็บที่อยู่ของคำสั่งถัดไปที่จะถูกประมวลผล

    **4. Cache Memory (หน่วยความจำแคช):** เก็บข้อมูลที่ถูกใช้บ่อยเพื่อเพิ่มความเร็วในการเข้าถึงข้อมูล.



---

# Register

- Registers:
    - เป็นหน่วยความจำที่ตั้งอยู่ในหน่วยประมวลผลข้อมูล (CPU)
    - มักใช้เก็บข้อมูลที่ใช้ในการประมวลผลโปรแกรม
    - มีความเร็วในการเข้าถึงสูงมาก

- Data Register: เก็บข้อมูลที่ใช้ในการคำนวณ
    - Instruction Register (IR): เก็บคำสั่งที่กำลังถูกประมวลผล
    - Program Counter (PC): เก็บที่อยู่ของคำสั่งถัดไปที่จะถูกประมวลผล

---

# Control Unit

- Control Unit (หน่วยควบคุม) คือองค์ประกอบหนึ่งใน CPU (Central Processing Unit) 
ที่มีหน้าที่ควบคุมการทำงานของคอมพิวเตอร์โดยรวม. 
    - ทำหน้าที่สำคัญในการอ่านคำสั่งจากหน่วยความจำ, 
แปลงคำสั่งเหล่านั้นเป็นสัญญาณที่สามารถทำงานได้โดย CPU, 
และควบคุมการทำงานของทุกๆ ส่วนของคอมพิวเตอร์
    - จัดการให้กับการทำงานทุก ๆ ส่วนของ CPU 
และประสานงานระหว่างคำสั่งแต่ละคำสั่งในโปรแกรมที่กำลังทำงาน
    - หน่วยควบคุมเป็นส่วนสำคัญที่ช่วยให้ CPU สามารถทำงานตามลำดับขั้นตอนของโปรแกรมได้อย่างถูกต้องและเรียบเนียน

---
layout: cover
---

# 2. Main Memory

---

# Main Memory

- "Main memory" หรือ "Primary memory" 
คือ เป็นส่วนที่คอมพิวเตอร์ใช้ในการเก็บข้อมูลชั่วคราวขณะทำงาน 
เช่น โปรแกรมที่กำลังเปิดใช้งาน ข้อมูลที่กำลังถูกประมวลผล และข้อมูลอื่นๆ ที่จำเป็นต้องใช้งานในขณะนั้น

- Main memory  เก็บข้อมูลและโปรแกรม  (อ้างอิงจากบทที่ 1.แบบจำลองของแวนนอยแมน)
หน่วยความจำหลักก็เหมือนกับตู้ลิ้นชักที่มีลิ้นชักจำนวนมาก 
แต่ละลิ้นชักจะมีป้ายชื่อบอกว่าเป็นลิ้นชักหมายเลขอะไร (ที่อยู่) 
และภายในลิ้นชักแต่ละอันก็จะเก็บข้อมูล (ขนาดของ Word) 

<img class="w-[600px] mx-auto" src="/images/chapter5/main_memory.png" />


---

# Main Memory (2)

- Address: เป็นเหมือนที่อยู่ของแต่ละตำแหน่งในหน่วยความจำหลัก คอมพิวเตอร์จะใช้ที่อยู่นี้ในการระบุตำแหน่งที่ต้องการเข้าถึงข้อมูล
- Contents (values): คือข้อมูลที่เก็บอยู่ในแต่ละตำแหน่งของหน่วยความจำหลัก ข้อมูลเหล่านี้อาจเป็นตัวเลข ตัวอักษร หรือคำสั่งต่างๆ
- Contents หรือ data ข้อมูลเป็นเลขฐานสอง พื้นที่เก็บข้อมูลต้องเท่ากันเสมอ เช่น กำหนดว่าเก็บข้อมูลได้ขนาด 8 bit ก็ 8 bit ทั้งหมด
ในภาพหน่วยความจำเก็บข้อมูลได้ 16 bit pattern หน่วยความจำขนาด 16 bit = 2 byte 

Main Memory มี address หรือที่อยู่ (address) สำหรับแต่ละหน่วยข้อมูลที่ถูกเก็บในหน่วยความจำ. 
ที่อยู่นี้ใช้เป็นตัวบ่งชี้เพื่อให้คอมพิวเตอร์สามารถเข้าถึงและอ่านหรือเขียนข้อมูลได้.
หน่วยความจำมีหมายเลขตำแหน่ง 0-1023 ดังนั้น 2<sup>10</sup> bit -1 =1023 หรือมี 1024 ตำแหน่ง 

Address apace = 1024 ตำแหน่ง หรือ ขนาด 10 bit


---

# Main Memory (3)

- หน่วยความจำหลักประกอบด้วยตำแหน่งสำหรับเก็บข้อมูลจำนวนมาก แต่ละตำแหน่งจะมีชื่อเรียกว่า "ที่อยู่" (address) ใช้สำหรับระบุตำแหน่งของข้อมูลแต่ละชิ้น
ข้อมูลที่ถูกส่งเข้าและออกจากหน่วยความจำจะถูกแบ่งเป็นกลุ่มๆ เรียกว่า "คำ" (word)
- word ขนาดของข้อมูล ถ้าหน่วยความจำมีขนาด 8 บิต 
1 word=8 bit
word เปลี่ยนแปลงไปตามขนาดข้อมูลในหน่วยความจำ

- ถ้า CPU มี word size 8 บิต, 
นั่นหมายถึง CPU สามารถประมวลผลข้อมูลที่มีขนาด 8 บิตในแต่ละรอบ
- ถ้าหน่วยความจำมี word size 16 บิต, 
นั่นหมายถึงขนาดข้อมูลที่สามารถอ่านหรือเขียนในครั้งเดียวในหน่วยความจำจะมีขนาด 16 บิต


---

# Address space

- Address Space หรือ พื้นที่ที่อยู่ (ในภาษาไทย) หมายถึง ช่วงของที่อยู่ทั้งหมด 
ที่ใช้ในการระบุตำแหน่งของข้อมูลภายในหน่วยความจำของคอมพิวเตอร์ 

- Address space" จำนวน Address ทั้งหมดที่ใช้อ้างอิงตำแหน่งในหน่วยความจำ 
หมายถึงช่วงที่อยู่หรือที่อยู่ที่สามารถให้การเข้าถึงได้ในหน่วยความจำ 
หรืออีกทางหนึ่งก็คือช่วงที่อยู่ที่ถูกกำหนดในหน่วยความจำของระบบ

---

# Memory Units

- หน่วยวัดขนาดของหน่วยความจำคอมพิวเตอร์

|Unit|Exact Number of Bytes|Approximation|
|----|----|----|
kilobyte (1 พัน)|2<sup>10</sup> (1024) bytes | 10<sup>3</sup> bytes
megabyte (1 ล้าน)|2<sup>20</sup> (1,048,576) bytes | 10<sup>6</sup> bytes
gigabyte (1 พันล้าน)|2<sup>30</sup> (1,073,741,824) bytes | 10<sup>9</sup> bytes
terabyte (1 ล้านล้าน)|2<sup>40</sup> bytes | 10<sup>9</sup> bytes


---

# การคำนวณ bit ในหน่วยความจำ

1. แปลงหน่วยความจำ
2. หาจำนวน Word
3. คำนวณจำนวนบิตที่ต้องการ


---

# โจทย์ 

1. หากคอมพิวเตอร์มีหน่วยความจำทั้งหมด 32 เมกะไบต์ (MB), เราสามารถหาว่าต้องใช้บิตเท่าไรในการที่จะที่อยู่ในแต่ละไบต์ในหน่วยความจำนี้ ?

    - มีหน่วยความจำ 32 MB 

    - 32 = 2<sup>5</sup>

    - MB = 2<sup>20</sup> bytes

    - 32 MB = 2<sup>5+20=25</sup> bytes

    - log<sub>2</sub> 2<sup>25</sup> = 25 bits

---

# โจทย์

2. ถ้าคอมพิวเตอร์มีหน่วยความจำทั้งหมด 128 เมกะไบต์ (MB) และแต่ละ "word" มีขนาด 8 ไบต์, เราสามารถหาว่าต้องใช้บิตเท่าไรในการที่จะที่อยู่ (address) แต่ละ "word" ในหน่วยความจำนี้ ?

    - 128 = 2<sup>7</sup>
    - MB = 2<sup>20</sup> bytes
    - มีหน่วยความจำ 128 MB หรือ 2<sup>20+7</sup> ไบต์
    - แต่ละ word มีขนาด 8 ไบต์ (2<sup>3</sup> ไบต์)
    - ดังนั้น มีจำนวน word ทั้งหมด 2<sup>24</sup> word (2<sup>27</sup> / 2<sup>3</sup>) = 2<sup>27-3</sup> ไบต์
    - log<sub>2</sub> 2<sup>24</sup> ไบต์
    - จึงต้องการ 24 บิตในการแทนค่าที่อยู่ของแต่ละคำ
    
---

# Memory Types

1. RAM (Random Access Memory)
2. ROM (Read Only Memory)


---

# RAM

- RAM (Random Access Memory)
    - Static RAM (SRAM)
    - Dynamic RAM (DRAM)

หน่วยความจำที่อ่านและเขียนได้ (Random Access Memory: RAM)

1. RAM หรือ หน่วยความจำเข้าถึงโดยสุ่ม เป็นหน่วยความจำหลักที่ใช้ในการเก็บข้อมูลชั่วคราวขณะที่คอมพิวเตอร์กำลังทำงาน 
เช่น โปรแกรมที่กำลังเปิดใช้งาน ข้อมูลที่กำลังถูกประมวลผล เป็นต้น 

2. ข้อมูลใน RAM จะหายไปเมื่อไฟฟ้าดับ
3. ข้อมูลใน RAM สามารถเข้าถึงได้ในเวลาเร็ว
4. RAM จะถูกเคลียร์เมื่อเครื่องคอมพิวเตอร์ปิด ซึ่งหมายความว่าข้อมูลทั้งหมดที่อยู่ใน RAM จะสูญหาย ดังนั้น RAM มักถูกใช้เพื่อเก็บข้อมูลที่ต้องการให้ระบบปฏิบัติการและโปรแกรมทำงานในขณะที่เครื่องคอมพิวเตอร์ทำงาน

---

# Static RAM (SRAM) 
- Static RAM (SRAM): 
    - เป็น RAM ที่มีราคาแพง 
    - แต่มีความเร็วในการเข้าถึงข้อมูลสูง 
    - มีความจุที่น้อยกว่า DRAM
    - เป็นรูปแบบของ RAM ที่ไม่ต้องการการรีเฟรช ใช้ในการเก็บข้อมูลที่ต้องเข้าถึงบ่อยๆ เช่น แคชเมมโมรี register แคช

---

# Dynamic RAM (DRAM)

- Dynamic RAM (DRAM): 
    - เป็น RAM ที่มีราคาถูกกว่า 
    - แต่มีความช้ากว่า SRAM 
    - มันมีความจุในการเก็บข้อมูลมาก, 
    - เป็นรูปแบบของ RAM ที่ต้องการการรีเฟรช (refresh) เพื่อรักษาข้อมูล 
    - ใช้เป็นหน่วยความจำหลักของคอมพิวเตอร์ main board ซื้อมาใส่


---

# ROM

- ROM (Read-only Memory)
    - Programmable read-only memory (PROM)
    - Erasable programmable read-only memory (EPROM)
    - Electriacally erasable programmable read-only memory (EEPROM)

ROM หรือ หน่วยความจำอ่านอย่างเดียว 

1. เป็นหน่วยความจำที่เก็บข้อมูลถาวรที่ไม่สามารถแก้ไขได้ง่ายๆ 
2. ข้อมูลใน ROM จะยังคงอยู่แม้ว่าจะปิดเครื่องคอมพิวเตอร์แล้วก็ตาม 
3. ROM มักถูกใช้ในการเก็บโปรแกรมพื้นฐานที่จำเป็นสำหรับการเริ่มต้นทำงานของคอมพิวเตอร์ เช่น BIOS
4. หรือในกรณีที่ไม่ต้องการให้ข้อมูลนั้นถูกเปลี่ยนแปลงหรือสูญหายเมื่อเครื่องคอมพิวเตอร์ถูกปิด


---

# PROM

- PROM (Programmable Read-Only Memory):
    - ลักษณะ: PROM เป็นหน่วยความจำที่สามารถโปรแกรมได้ ครั้งเดียวเท่านั้น หลังจากโปรแกรมได้ถูกโปรแกรมลงไปแล้ว, ข้อมูลใน PROM จะไม่สามารถเขียนทับหรือแก้ไขได้
    - การใช้งาน: PROM มักถูกใช้ในการเก็บโปรแกรมหรือข้อมูลที่คงที่และไม่มีการเปลี่ยนแปลงบ่อย

---

# EPROM (Erasable Programmable Read-Only Memory):

- Erasable programmable read-only memory (EPROM)

    - ลักษณะ: EPROM เหมือนกับ PROM ในทางหลัก แต่มีความสามารถในการลบข้อมูลและโปรแกรมที่ถูกโปรแกรมไว้มาก่อนได้ การลบข้อมูลใน EPROM ต้องทำผ่านกระบวนการที่เรียกว่า "erasing" โดยใช้การโปรยสารภายนอกหน่วยความจำ
    - การใช้งาน: EPROM มักถูกใช้ในการพัฒนาและทดสอบโปรแกรม, โดยนักพัฒนาสามารถโปรแกรมใหม่ลงไปหลังจากลบข้อมูลใน EPROM
EPROM (Erasable Programmable ROM): สามารถลบข้อมูลและเขียนใหม่ได้ โดยใช้การลบด้วยแสง UV


---

# EEPROM (Electrically Erasable Programmable Read-Only Memory):

- EEPROM (Electrically Erasable Programmable ROM): สามารถลบข้อมูลและเขียนใหม่ได้ โดยใช้กระแสไฟฟ้า

    - ลักษณะ: EEPROM เป็นหน่วยความจำที่สามารถลบข้อมูลและโปรแกรมได้โดยใช้ไฟฟ้า โดยไม่ต้องนำออกจากระบบหรือใช้อุปกรณ์เสริม
    - การใช้งาน: EEPROM มักถูกใช้ในการเก็บข้อมูลที่ต้องการทำการอ่านและเขียนบ่อย, เช่น การเก็บข้อมูลการตั้งค่าในอุปกรณ์ต่าง ๆ



---

# สรุป

- สรุป, PROM, EPROM, และ EEPROM คือหน่วยความจำที่สามารถโปรแกรมได้ แต่มีความแตกต่างกันในรูปแบบการลบข้อมูลหรือโปรแกรมที่ถูกโปรแกรมลงไป PROM มีการโปรแกรมเพียงครั้งเดียว, EPROM สามารถลบและโปรแกรมใหม่ได้โดยการใช้แสง, และ EEPROM สามารถลบและโปรแกรมใหม่ได้โดยการใช้ไฟฟ้า

---

# ระดับของ Memory

<div class="flex gap-3">
<div>

1. Registers

2. Cache memory

3. Main memory
</div>
<img src="/images/chapter5/memory_hierachy.svg"/>
</div>


---

# Cache Memory

- Cache Memory:
    - ลักษณะ: Cache memory เป็นหน่วยความจำที่ใช้เก็บข้อมูลที่ถูกเข้าถึงบ่อยครั้ง เพื่อเพิ่มประสิทธิภาพในการเข้าถึงข้อมูล 
    - มีหลายระดับขนาดของ Cache (L1, L2, L3) แต่ละระดับให้ความเร็วในการเข้าถึงข้อมูลต่างกัน

<img src="/images/chapter5/cache_memory.png" class="mx-auto w-96 mt-2"/>

---

# Cache Memory (2)


- Cache มีการออกแบบให้มีความเร็วในการอ่านและเขียนข้อมูลมากกว่าหน่วยความจำหลัก 

    - ความเร็ว: Cache memory มีความเร็วมากเมื่อเทียบกับหน่วยความจำหลัก (RAM) เนื่องจากมักติดตั้งในโปรเซสเซอร์หรือใกล้กับหน่วยประมวลผล (CPU) เพื่อลดระยะทาง
    - ขนาดเล็ก: Cache memory มีขนาดเล็กเมื่อเทียบกับหน่วยความจำหลัก ซึ่งช่วยให้สามารถเข้าถึงข้อมูลได้เร็วมาก
    - แบ่งเป็นระดับ: Cache มักถูกแบ่งเป็นหลายระดับ เช่น L1 Cache, L2 Cache, และ L3 Cache โดย L1 มีขนาดเล็กและอยู่ใกล้ CPU มากที่สุด, ในขณะที่ L3 มีขนาดใหญ่และอยู่ห่างจาก CPU มากที่สุด
    - การจัดเก็บข้อมูล: Cache จัดเก็บข้อมูลที่ถูกใช้งานล่าสุดโดยรอบ, โดยมีแนวโน้มที่จะเก็บข้อมูลที่ถูกเข้าถึงบ่อยที่สุด
    - การใช้หน่วยความจำ Cache ช่วยลดเวลาที่ CPU ต้องใช้ในการรอข้อมูลจากหน่วยความจำหลัก ซึ่งเป็นอีกหนึ่งวิธีที่ระบบคอมพิวเตอร์สามารถทำงานได้เร็วขึ้น

---
layout: cover
---

# 3. INPUT/OUTPUT (3)

---

# INPUT/OUTPUT

- เป็นชุดของอุปกรณ์ในคอมพิวเตอร์
- เพื่อสื่อสารกับภายนอก และ บันทึกข้อมูลภายใน
- แบ่งเป็น non-storage และ storage

---

# NON-STORAGE

- อนุญาติให้ CPU/Memory สามารถสื่อสารกับภายนอกคอมพิวเตอร์ แต่ไม่สามารถบันทึกข้อมูลภายใน เช่น Keyboard, Monitor, Printer


# STORAGE DEVICES

- บันทึกข้อมูลขนาดมหาศาลและสามารถดึงมาใช้ภายหลังได้
- ราคาถูกกว่า Main Memory และข้อมูลจะไม่สูญหายเมื่อปิดตัวลง แบ่งเป็น Magnetic หรือ Optical


<!-- Buffer คือ ส่วนหนึ่งของหน่วยความจำที่ใช้สำหรับพักข้อมูลเป็นการชั่วคราวในระหว่างทำการถ่ายทอด หรือส่งผ่านข้อมูล เครื่องอุปกรณ์คอมพิวเตอร์บางชนิดจะมี Buffer ของตนเอง เช่น เมื่อเราสั่งปริ๊นงานไปยังเครื่องพิมพ์ ข้อมูลที่จะให้ปริ้นต์จะถูกส่งมาที่ CPU เพื่อรอปริ้น แต่ถ้าคุณสั่งปริ้นข้อมูลจำนวนหลายหน้า แล้วหน่วยความจำไม่พอ ก็จะต้องมีตัวที่เก็บข้อมูลที่จะปริ้นต์ ลงไปที่ไหนสักแห่งแทนหน่วยความจำซึ่งตัวเก็บข้อมูลปนี้คือ Buffer นั้นเอง -->


---
layout: cover
---

# SUBSYSTEM INTERCONNECTION (4)


---

# INTERCONNECTION

- "Interconnection" แปลว่า "การเชื่อมต่อ" หรือ "การเชื่อมโยง" (ในภาษาไทย) คำนี้ใช้เพื่อบ่งบอกถึงกระบวนการหรือการทำให้สิ่งต่าง ๆ เชื่อมต่อหรือเชื่อมโยงกัน เพื่อให้ทำงานร่วมกันหรือทำหน้าที่ร่วมกันในระบบหรือโครงสร้างที่ซับซ้อน ในทางทฤษฎีคอมพิวเตอร์หรือวงจรอิเล็กทรอนิกส์, คำนี้บ่งบอกถึงการเชื่อมต่อส่วนต่าง ๆ ของระบบหรือวงจรเพื่อให้สามารถทำงานร่วมกันได้

    - ต่อกับ CPU, memory
    - ต่อกับ I/O devices
    - การอ้างอิงที่อยู่ input/output devices


---

# ต่อกับ CPU, memory

- "Bus" ในทางทฤษฎีคอมพิวเตอร์หมายถึงทางสายสัญญาณที่ใช้ในการส่งข้อมูลระหว่างส่วนต่าง ๆ ของระบบคอมพิวเตอร์ ซึ่งเป็นช่องทางสำหรับการสื่อสารระหว่างอุปกรณ์ต่าง ๆ ในคอมพิวเตอร์หรือระบบอิเล็กทรอนิกส์ ตัวอย่างของ Bus ที่สำคัญมีดังนี้:
ระบบบัสข้อมูล (Data Bus): ใช้สำหรับการส่งข้อมูลจริง ๆ ระหว่างหน่วยความจำ, CPU, และอุปกรณ์อื่น ๆ
ระบบบัสที่ใช้สำหรับการส่งคำสั่ง (Address Bus): ใช้สำหรับการระบุตำแหน่งหรือที่อยู่ของข้อมูลที่ต้องการถึงในหน่วยความจำ
ระบบบัสควบคุม (Control Bus): ใช้สำหรับส่งสัญญาณควบคุมเพื่อควบคุมการทำงานของอุปกรณ์ต่าง ๆ ในระบบ
Bus เป็นองค์ประกอบสำคัญที่ช่วยให้อุปกรณ์ต่าง ๆ ในระบบคอมพิวเตอร์สามารถแลกเปลี่ยนข้อมูลกันได้อย่างมีระบบและเป็นระบบ การออกแบบ Bus มีความสำคัญในการปรับปรุงประสิทธิภาพของระบบคอมพิวเตอร์


<img src="/images/chapter5/data_busses.png" class="mx-auto w-[500px] mt-2"/>

---

# ต่อกับ I/O devices

- การเชื่อมต่อ I/O device ทำให้ระบบคอมพิวเตอร์สามารถทำงานกับต่าง ๆ อุปกรณ์ภายนอก เช่น คีย์บอร์ด, เมาส์, จอภาพ, เครื่องพิมพ์, กล้อง, ลำโพง, และอุปกรณ์ต่าง ๆ ที่ให้บริการในการป้อนข้อมูลและแสดงผล

- ไม่สามารถต่อกับ CPU หรือ Memory ผ่าน Bus ได้โดยตรง จะต้องอาศัย input/output controllers 

---

# ต่อกับ I/O devices

<img src="/images/chapter5/bus_hw.png" class="mx-auto w-[500px] mt-2"/>

---

# Addressing input/output devices

- "การกำหนดที่อยู่ของอุปกรณ์นำเข้า/นำออก" คือกระบวนการที่ใช้ที่อยู่หรือที่ตำแหน่งเพื่อระบุตำแหน่งที่ตั้งของอุปกรณ์นำเข้าหรือนำออกในระบบคอมพิวเตอร์
ในระบบคอมพิวเตอร์,
- ทุกอุปกรณ์ I/O จะต้องถูกกำหนดที่อยู่ (address) เพื่อให้ระบบสามารถรู้ว่าอุปกรณ์นั้นๆ ตั้งอยู่ที่ไหนในพื้นที่หน่วยความจำหรือระบบ 
- ที่อยู่นี้เป็นตัวบอกตำแหน่งที่ตั้งของอุปกรณ์ในเขตหน่วยความจำหรือที่เก็บข้อมูล (Memory address)
- การอ้างอิงที่อยู่ของอุปกรณ์ I/O จะใช้ในการสื่อสารระหว่าง CPU และอุปกรณ์ I/O เพื่อทำงานต่าง ๆ 
เช่น การส่งข้อมูลเข้า (input) หรือการรับข้อมูลออก (output) 
- ในทางปฏิบัติ, การกำหนดที่อยู่นี้มักถูกทำเป็นแบบฮาร์ดแวร์ (Hardware Addressing) โดยใช้สายไฟหรือหลอดไฟที่เชื่อมต่อกับอุปกรณ์ I/O เพื่อให้ CPU สามารถระบุที่อยู่ของอุปกรณ์ได้

---

# Addressing input/output devices (2)

- บัสเดียวกัน: CPU ใช้บัสเดียวกันในการสื่อสารทั้งกับหน่วยความจำหลัก (Main Memory) และอุปกรณ์ Input/Output (I/O)
- คำสั่งต่างกัน: สิ่งที่ทำให้การสื่อสารแตกต่างกันคือ "คำสั่ง" ที่ CPU ส่งไป 
    - คำสั่งเข้าถึงหน่วยความจำ: ถ้าคำสั่งต้องการเข้าถึงข้อมูลในหน่วยความจำหลัก ข้อมูลจะถูกส่งระหว่างหน่วยความจำหลักกับ CPU
    - คำสั่งเข้าถึงอุปกรณ์ I/O: ถ้าคำสั่งต้องการเข้าถึงอุปกรณ์ I/O ข้อมูลจะถูกส่งระหว่างอุปกรณ์ I/O กับ CPU


---

# Addressing input/output devices (3)


- โดยมีวิธีการหลักๆ 2 วิธีในการเข้าถึงอุปกรณ์เหล่านี้:
    1. Isolated I/O: วิธีนี้เป็นการแยกที่อยู่สำหรับการเข้าถึงหน่วยความจำและอุปกรณ์ I/O ออกจากกันอย่างชัดเจน 
คำสั่งที่ใช้ในการเข้าถึงหน่วยความจำจะแตกต่างจากคำสั่งที่ใช้ในการเข้าถึงอุปกรณ์ I/O 
ทำให้การควบคุมการเข้าถึงมีความชัดเจน แต่ต้องมีชุดคำสั่งที่ซับซ้อนกว่า

    2. Memory-mapped I/O: วิธีนี้เป็นการนำอุปกรณ์ I/O มาจัดอยู่ในพื้นที่หน่วยความจำ 
ทำให้สามารถเข้าถึงอุปกรณ์ I/O ได้โดยใช้คำสั่งเดียวกับที่ใช้ในการเข้าถึงหน่วยความจำ 
ทำให้การเขียนโปรแกรมง่ายขึ้น แต่มีความเสี่ยงที่โปรแกรมจะเข้าไปเขียนข้อมูลทับส่วนที่เป็นอุปกรณ์ I/O ได้โดยไม่ตั้งใจ


---

# Isolated I/O

- ใช้คำสั่งในการอ่านเขียนต่างกัน
สมมุติหน่วยความจำมีแอดเดรส space 100  100 ช่อง
 คอนโทรลเลอร์ เองก็มีหมายเลขเหมือนกับเมมโมรี่หน่วยความจำ
ไอโอกับ memory มีแอดเดรสซ้ำกันได้

- Isolated I/O: 
วิธีนี้เป็นการแยกที่อยู่สำหรับการเข้าถึงหน่วยความจำและอุปกรณ์ I/O ออกจากกันอย่างชัดเจน 
คำสั่งที่ใช้ในการเข้าถึงหน่วยความจำจะแตกต่างจากคำสั่งที่ใช้ในการเข้าถึงอุปกรณ์ I/O 
ทำให้การควบคุมการเข้าถึงมีความชัดเจน แต่ต้องมีชุดคำสั่งที่ซับซ้อนกว่า

<img src="/images/chapter5/isolated_device.png" class="mx-auto w-[500px] mt-2"/>


---

# Memory mapped I/O Addressing

- การใช้ Memory-mapped I/O (Input/Output) addressing หมายถึงวิธีการในสถาปัตยกรรมคอมพิวเตอร์
ที่ใช้พื้นที่ที่อยู่เดียวกันในการเข้าถึงทั้งหน่วยความจำและอุปกรณ์ I/O 
โดยในวิธีนี้ ที่อยู่บางอย่างภายในพื้นที่ที่อยู่ของหน่วยความจำถูกกำหนดไว้สำหรับการสื่อสารกับอุปกรณ์ต่าง ๆ
 โดยจัดเหล่าที่อยู่นี้เหมือนกับตำแหน่งในหน่วยความจำ

- สมมุติแอดเดรส space 65,000 ช่องใช้หน่วยความจำได้ไม่เต็มจำนวนที่มีอยู่ 
ตรงนี้จะเห็นว่าเป็นช่องที่ 64000 หมายเลขที่เหลือเอาไปกำหนดให้ไอโอ  มีส่วนหนึ่งถูกจัดสรรให้ไอโอคอนโทรลเลอร์ 
และการติดต่อก็คือดูจากหมายเลขแอดเดรส  ถ้าแอดเดรสระบุว่าหน่วยความจำก็เอาข้อมูลจากหน่วยความจำ 

- ข้อดีจำนวนคำสั่งน้อย ข้อเสียเสียส่วนหนึ่งของ memory แอดเดรส space 

---

# Memory mapped I/O Addressing (2)

- Memory-mapped I/O: วิธีนี้เป็นการนำอุปกรณ์ I/O มาจัดอยู่ในพื้นที่หน่วยความจำ 
ทำให้สามารถเข้าถึงอุปกรณ์ I/O ได้โดยใช้คำสั่งเดียวกับที่ใช้ในการเข้าถึงหน่วยความจำ
 ทำให้การเขียนโปรแกรมง่ายขึ้น แต่มีความเสี่ยงที่โปรแกรมจะเข้าไปเขียนข้อมูลทับส่วนที่เป็นอุปกรณ์ I/O ได้โดยไม่ตั้งใจ

<img src="/images/chapter5/memory_mapped_io.png" class="mx-auto w-[500px] mt-2"/>


---
layout: cover
---
# Program Execution (5)

---

# Program

- ทุกวันนี้ PC ใช้ชุดคำสั่งที่เรียกว่า **Program**
- คอมพิวเตอร์จะนำผลลัพธ์ที่ได้จาก Program ผ่านการป้อนข้อมูล ซึ่งโปรแกรมและข้อมูลนั้นจะถูกเก็บลงในหน่วยความจำ


---

# Machine Cycle

- "Machine cycle" หรือ "รอบการทำงานของเครื่อง" เป็นกระบวนการทำงานพื้นฐานของหน่วยประมวลผล (CPU: Central Processing Unit) ในคอมพิวเตอร์ ซึ่งประกอบด้วยชุดของการดำเนินการที่ CPU ทำในลำดับที่กำหนด 

- Machine cycle ประกอบด้วยสามขั้นตอนหลัก คือ:

    **1. Fetch** เป็นกระบวนการที่หน่วยควบคุมนำชุดคำสั่งจากหน่วยความจำ (แคชหรือแรม) มาเก็บไว้ในรีจิสเตอร์

    **2. Decode** เป็นกระบวนการถอดรหัสเพื่อแปลความหมายชุดคำสั่ง เพื่อเตรียมส่งไปยังหน่วย ALU

    **3. Execute** เป็นกระบวนการประมวลผลชุดคำสั่งโดยหน่วย ALU เพื่อทำงานตามที่ต้องการ โดยจะประมวลผลแบบทีละคำสั่ง


<img src="/images/chapter5/machine_cycle.png" class="mx-auto w-96 mt-2"/>

---

# INPUT/OUTPUT Operation (I/O Operation)

- การทำงานของ I/O คือ วิธีการที่คอมพิวเตอร์สื่อสารและแลกเปลี่ยนข้อมูลกับอุปกรณ์ภายนอกต่างๆ เช่น คีย์บอร์ด เมาส์ จอภาพ หรือฮาร์ดดิสก์ การทำงานของหน่วยไอโอต้องมีคำสั่งถ้าจะใช้งาน ไอโอต้องมีการสั่งว่าจะใช้ การทำงานของไอโอช้ากว่าซีพียู  ต้องมีการรอ หรือมีการประสานงานทำงานการเข้าจังหวะ

- **การถ่ายโอนข้อมูล:** ต้องมีคำสั่งในการถ่ายโอนข้อมูลระหว่างอุปกรณ์ I/O กับ CPU และหน่วยความจำ

- **การประสานงาน:** การทำงานของ CPU และอุปกรณ์ I/O ต้องมีความสอดคล้องกัน

- วิธีการประสานงาน: มี 3 วิธีหลักในการประสานงานการทำงาน


    **1. Programmed I/O**

    **2. Interrupt driven I/O**
    
    **3. Direct Memory Access (DMA)**


---

# Programmed I/O
<div class="flex gap-3">
<div>

- การทรานสเฟอร์ข้อมูลระหว่างไอโอ และซีพียู
    1. ถูกส่งโดยคำสั่งในโปรแกรมหนึ่งเมื่อมีการทำคำสั่งเมื่อซีพียูพบไอโอ 
    2. ก็จะ Fetch และ Decode มาได้ว่าจะใช้ไอโอก็ 
    3. สั่งงานไอโอร้องขอใช้ไอโอ (Issue I/O command)
    4. ตรวจสอบสถานะของไอโอว่าไอโอพร้อมหรือยัง (Check device status) เช่นเครื่องพิมพ์อาจจะพิมพ์อยู่ก็ร้องขอใช้เครื่องพิมพ์แล้วก็ซีพียูรอไอโอ
        - ถ้าพร้อมพร้อมแล้วก็ส่งข้อมูล (Transfer a word) รอคำสั่งถัดไป
        - ถ้ายังใช้ไอโออยู่ก็สั่งมาโดยซีพียูวนรอ 

</div>
<img src="/images/chapter5/programmed_io.png" class="mx-auto w-96 mt-2"/>
</div>

---

# Programmed I/O (2)

- สรุปคือเสียเวลาการทำงานของซีพียูไม่สามารถทำงานอย่างอื่นได้ เพราะ

    1. CPU จะคอยตรวจสอบสถานะของอุปกรณ์ I/O อยู่ตลอดเวลา

    2. เมื่ออุปกรณ์ I/O พร้อมที่จะส่งหรือรับข้อมูล CPU จะดำเนินการถ่ายโอนข้อมูล

    3. วิธีนี้ค่อนข้างง่าย แต่ทำให้ CPU ต้องเสียเวลาไปกับการตรวจสอบสถานะของอุปกรณ์ I/O อยู่บ่อยครั้ง


---

# Interrupt-driven I/O

<div class="flex gap-3">
<div>

- คำสั่ง excecute มาสั่งให้ทำงานไอโอ 
    1. ซีพียูไปทำงานอย่างอื่นได้ไป Fetch, Decode, Execute 
    2. แต่เฝ้ารอการตอบกลับจากไอโอ 
    3. เมื่อไอโอพร้อมก็ขัดจังหวะซีพียูเข้ามา 
    4. ซีพียูก็จะทำงานใน Machine ไซเคิลให้เสร็จ
    5. แล้วค่อยมาทำคำสั่งคำสั่งนั้น 

</div>
<img src="/images/chapter5/interrupt_driven_io.png" class="mx-auto w-96 mt-2"/>
</div>

---

# Interrupt-driven I/O (2)

- สรุป
    1. อุปกรณ์ I/O จะส่งสัญญาณขัดจังหวะ (interrupt) ไปยัง CPU เมื่อพร้อมที่จะส่งหรือรับข้อมูล
    2. CPU จะหยุดการทำงานปัจจุบันชั่วคราวเพื่อมาจัดการกับสัญญาณขัดจังหวะ และดำเนินการถ่ายโอนข้อมูล
    3. วิธีนี้ทำให้ CPU สามารถทำงานอย่างอื่นได้ขณะรอข้อมูลจากอุปกรณ์ I/O แต่ต้องมีกลไกในการจัดการสัญญาณขัดจังหวะ

---

# Direct Memory Access

<div class="flex flex-col gap-3">
<div>

- เป็นกระบวนการเฉพาะการถ่ายโอนข้อมูล Direct Memory Access เช่นไอโอที่เป็นดิสถ่ายโอนข้อมูลกับหน่วยความจำโอน โดยโอนเป็นบล็อกเป็นก้อน

<div class="flex gap-3">
<div class="w-1/2">

- ซีพียูได้รับคำสั่งให้นำข้อมูลจากดิสมาใช้ ซีพียูจะเอาข้อมูลจาก Disk มาใช้โดยตรงไม่ได้ 
ซีพียูจะต้องได้รับคำสั่งให้ถ่ายโอนข้อมูลจากดิสไปหน่วยความจำก่อน โดยกระบวนการมีดังนี้

    1. CPU ส่งคำสั่งไปที่ DMA
    2. DMA ตอบรับขอใช้ BUS หลังจากนั้น CPU หยุดใช้ BUS และมอบ BUS ให้ DMA
    3. ดึงข้อมูลจาก Disk
    4. DMA ตอบ กลับ Disk ว่าได้ข้อมูลแล้ว 
    5. ส่งข้อมูลไป Main memory เป็นก้อนผ่าน DMA 
    

</div>

<img src="/images/chapter5/dma.png" class="w-1/2 mt-2"/>
</div>
</div>
</div>

---

# Direct Memory Access (2)

- สรุป 
    1. อุปกรณ์ I/O จะสามารถเข้าถึงหน่วยความจำโดยตรงโดยไม่ต้องผ่าน CPU
    2. CPU จะทำการตั้งค่าการถ่ายโอนข้อมูลให้กับอุปกรณ์ I/O แล้วปล่อยให้อุปกรณ์ I/O ดำเนินการเอง
    3. วิธีนี้ทำให้ CPU ไม่ต้องเสียเวลาในการถ่ายโอนข้อมูล ทำให้เพิ่มประสิทธิภาพในการทำงาน
    
---

# Direct Memory Access (3)

<div class="flex gap-3">
<div>

มีคำสั่งกระบวนการเอาข้อมูลจาก Disk มา Main memory
โดย CPU ขอใช้ DMA เป็นลักษณะหนึ่งของ interupt io

- ถ้า DMA พร้อมก็  interupt เข้ามาบอก CPU 
- CPU ปล่อย Bus ให้ DMA เข้าถึง Bus 
- CPU รอ DMA เสร็จ ระหว่างนั้น CPU ทำงานอย่างอื่นได้ (ยกเว้นใช้ Bus)
- ถ้า DMA เสร็จก็ interrupt ไปบอก CPU แล้ว CPU ก็จะทำคำสั่งต่อไป

</div>
<img src="/images/chapter5/dma2.png" class="w-1/2 mt-2"/>
</div>


---
layout: cover
---

# Different Architecture

---

# Description

- สถาปัตยกรรมของคอมพิวเตอร์ได้มีการเปลี่ยนแปลงเป็นจำนวนมากมาหลายทศวรรษ ดังจะเห็นได้จาก
    1. CISC
    2. RISC
    3. Pipelining
    4. Parallel processing

---

# CISC (Complex Instruction Set Computer)

- คอมพิวเตอร์เดสก์ท็อปทีพีที่ใช้กันในปัจจุบันเช่นตระกูลอินเทล เอเอ็มดี
- เป็นซีพียูที่มีชุดคำสั่งที่ซับซ้อน  ภายในซีพียูประกอบด้วยชุดคำสั่งจำนวน ทั้งชุดคำสั่งพื้นฐานและชุดคำสั่งซับซ้อน
- ข้อดี โปรแกรมหรือซอฟต์แวร์ต่างๆที่ออกแบบมาเพื่อใช้งานกับซีพียูแบบซิกจึงใช้ประโยชน์จากคำสั่งที่บรรจุอยู่ภายในซิกได้  จึงเขียนโปรแกรมได้ง่ายสั้นกว่า
- ข้อเสีย 
    - ซีพียูบรรจุคำสั่งมาก มีขนาดใหญ่ 
    - ใช้พลังงานพลังงานมาก  ความร้อนสูง 
    - คำสั่งมาก  อาจไม่ถูกเรียกใช้เป็นการเขียนโปรแกรมภาษาระดับต่ำ แต่ภาษาระดับสูงเนี่ยไม่ต่างกัน


---

# RISC (Reduced Instruction Set Computer)

- กลยุทธ์เบื้องหลังสถาปัตยกรรม RISC คือการมีชุดคำสั่งขนาดเล็กที่ทำการดำเนินการง่ายๆ ให้น้อยที่สุด

- คำสั่งที่ซับซ้อนจะถูกจำลองโดยใช้ชุดย่อยของคำสั่งง่ายๆ

- การเขียนโปรแกรมใน RISC นั้นยากกว่าและใช้เวลานานกว่าการออกแบบแบบอื่น เนื่องจากคำสั่งที่ซับซ้อนส่วนใหญ่จะจำลองโดยใช้คำสั่งง่ายๆ


---

# Pipelining


- คอมพิวเตอร์ใช้สามขั้นตอน ได้แก่ ดึงข้อมูล ถอดรหัส และดำเนินการสำหรับแต่ละคำสั่ง

- ในคอมพิวเตอร์ยุคแรก จำเป็นต้องดำเนินการทั้งสามเฟสนี้แบบอนุกรมสำหรับแต่ละคำสั่ง

- เทคนิคที่เรียกว่าการวางท่อเพื่อปรับปรุงปริมาณงาน

    - หน่วยควบคุมสามารถดำเนินการสองหรือสามเฟสเหล่านี้ได้พร้อมๆ กัน โดยสามารถเริ่มคำสั่งถัดไปได้ก่อนที่คำสั่งก่อนหน้าจะเสร็จสิ้น

---

# Pipelining (2)

<div class="flex gap-3">
<div class="w-1/2">

- Pipeline ก็คือการทำงานโดยไม่มีการรอ เมื่อทำงานนั้นเสร็จและส่งข้อมูลเรียบร้อยแล้ว จะ
ต้องทำงานตามคำสั่งต่อไปทันที ดังนั้นจึงไม่มีการว่างงานเกิดขึ้นในสัญญาณนาฬิกา

- ***ให้สังเกตุลูกศรสีแดง*** แสดงถึงว่า เมื่อ Fetch เสร็จแล้ว ก็จะทำการ Fetch คำสั่งถัดไปทันที ไม่หยุด ในทางกลับกัน Decode ก็จะ Decode คำสั่งถัดไป และ Execute ก็จะ Execute คำสั่งถัดไป ไม่มีการหยุดรอเช่นกัน

</div>
<img src="/images/chapter5/pipelining2.png" class="w-1/2"/>
</div>

---

# Parallel Processing

- การประมวลผลแบบขนาน หมายถึงการแบ่งงานประมวลผลออกเป็นส่วนย่อยๆ หลายส่วน แล้วนำส่วนย่อยเหล่านั้นไปประมวลผลพร้อมกัน โดยใช้หน่วยประมวลผลหลายตัว หรือหลายแกนประมวลผล ทำให้สามารถทำงานได้เร็วขึ้นและมีประสิทธิภาพมากขึ้นกว่าการประมวลผลแบบลำดับ (sequential processing) ที่ทำทีละขั้นตอน แบ่งเป็น 4 รูปแบบ

    - SISD (Single Instruction, Single Data): ใช้คำสั่งเดียวกันกับข้อมูลชุดเดียวกัน เหมาะสำหรับงานที่ไม่ซับซ้อน
    
    - SIMD (Single Instruction, Multiple Data): ใช้คำสั่งเดียวกันกับข้อมูลหลายชุด เหมาะสำหรับงานประเภทเวกเตอร์ เช่น การประมวลผลภาพ
    
    - MISD (Multiple Instruction, Single Data): ใช้คำสั่งหลายคำสั่งกับข้อมูลชุดเดียวกัน เหมาะสำหรับงานที่ต้องใช้ขั้นตอนการคำนวณที่แตกต่างกัน
    
    - MIMD (Multiple Instruction, Multiple Data): ใช้คำสั่งหลายคำสั่งกับข้อมูลหลายชุด เหมาะสำหรับงานที่ซับซ้อนและต้องการกำลังประมวลผลสูง เช่น การจำลองระบบ, การวิเคราะห์ข้อมูลขนาดใหญ่
    
---

# Parallel Processing (2)

<div class="flex gap-3 items-center">
<div class="w-1/2">

1. SISD คือ โปรเซสเซอร์ทีใช้การประมวลผลด้วยชุดข้อมูลเพียงชุดเดียวและทำงานด้วยคำสั่งเดียว 
2. SIMD คือ ประมวลผลด้วยชุดข้อมูลหลายชุดแต่ทำงานด้วยคำสั่งเดียว ภายใน 1สัญญาณนาฬิกาและได้ผลลัพธ์หลายชุดใช้ในโปรเซสเซอร์แบบPentium MMX  
3. MISD คือ โปรเซสเซอร์ทีใช้การประมวลผลดว้ยชุดข้อมูลเพียงชุดเดียวแต่ทำงานได้หลายคำสั่ง ไม่ค่อยมีใครพัฒนาโปรเซสเซอร์แบบนี   มีหลายหน่วยประมวลผลทำงานพร้อม ๆ กันกับข้อมูลเดียว โครงสร้างนี้ไม่ได้ใช้แพทเทิร์นที่พบบ่อยและมักนำเสนอในทฤษฎีเพื่อแสดงความหลากหลายในโครงสร้าง
4. MIMD คือ โปรเซสเซอร์ทีใช้การประมวลผลด้วยชุดข้อมูลหลายชุดและทำงานได้หลายคำสั่ง ภายใน 1สัญญาณนาฬิกา

</div>
<div class="w-1/2">
<img src="/images/chapter5/parallel_processing.png" />
</div>
</div>

---

# SISD

<div class="flex gap-3">
<div class="w-1/2">

- SISD คือ โปรเซสเซอร์ทีใช้การประมวลผลด้วยชุดข้อมูลเพียงชุดเดียวและทำงานด้วยคำสั่งเดียว ประกอบไปด้วย 

    - ชุดข้อมูล (Data stream)
    - CU 1 ตัว
    - PU 1 ตัว
    - Main memory 1 ตัว

</div>
<div class="w-1/2">
<img src="/images/chapter5/sisd.png" />
</div>
</div>

---

# SIMD

<div class="flex gap-3">
<div class="w-1/2">

- SIMD คือ ประมวลผลด้วยชุดข้อมูลหลายชุดแต่ทำงานด้วยคำสั่งเดียว ภายใน 1 สัญญาณนาฬิกาและได้ผลลัพธ์หลายชุด ใช้ในโปรเซสเซอร์แบบ Pentium MMX  ประกอบด้วย

    - ชุดข้อมูลหลายชุด (Data streams)
    - CU 1 ตัว
    - ALU หลายๆตัว
    - MU หลายๆตัว 


</div>
<div class="w-1/2">
<img src="/images/chapter5/simd.png" />
</div>
</div>

---

# MIMD

<div class="flex gap-3">
<div class="w-1/2">

- MIMD (Multiple Instruction Multiple Data stream) คือ โปรเซสเซอร์ทีใช้การประมวลผลด้วยชุดข้อมูลหลายชุดและทำงานได้หลายคำสั่ง ภายใน 1 สัญญาณนาฬิกา ประกอบด้วย
    - ชุดข้อมูลหลายชุด (Data streams)
    - CU หลายๆตัว
    - ALU หลายๆตัว
    - MU หลายๆตัว


</div>
<div class="w-1/2">
<img src="/images/chapter5/mimd.png" />
</div>
</div>

---
layout: cover
---

# A simple computer

---

# A Simple computer

<div class="flex gap-3">
<div class="w-1/2">

ประกอบด้วย

1. Main memory
2. CPU
3. I/O

- 1 Word = 16 bit หรือ 2 bytes (ดูจากความกว้างของหน่วยความจำ)
- Address Space มีขนาด  8 bit หรือ 2<sup>8</sup> = 256 ช่อง

หน่วยความจำใช้ไม่หมด  การเชื่อมต่อแบบ memory map I/O หมายเลข I/O ใช้ต่อเนื่องจากหน่วยความจำ 

ดังนั้นหน่วยความจำมีขนาด 254 × 2 = 508 bytes


</div>
<div class="w-1/2">
<img src="/images/chapter5/simple_computer.png" />
</div>
</div>

---

# Instruction set

- ชุดคำสั่ง **(Instruction set)** คือ รายการของคำสั่งที่คอมพิวเตอร์สามารถทำความเข้าใจและปฏิบัติตามได้ คำสั่งเหล่านี้เป็นเหมือนภาษาที่คอมพิวเตอร์ใช้ในการสื่อสารและสั่งงานให้ทำสิ่งต่างๆ

โครงสร้างของคำสั่ง:

- **Opcode (รหัสคำสั่ง):** เป็นส่วนที่ระบุชนิดของการทำงานที่ต้องการให้คอมพิวเตอร์ทำ เช่น การบวก การลบ การคูณ การหาร หรือการย้ายข้อมูล

- **Operand (ตัวถูกดำเนินการ):** เป็นส่วนที่ระบุข้อมูลที่เกี่ยวข้องกับการทำงาน เช่น ตัวเลขที่ต้องการนำมาคำนวณ หรือตำแหน่งหน่วยความจำที่ต้องการเข้าถึง

- คำสั่งหนึ่งจะมีขนาด 16 bit (2 bytes) และแบ่งออกเป็น 4 ส่วน แต่ละส่วนมีขนาด 4 bit (1 byte) โดย

    - **4 bit ซ้ายสุด:** ใช้สำหรับเก็บ opcode

    - **อีก 12 bit:** ใช้สำหรับเก็บ operand หรือที่อยู่ของ operand


---

# Instruction set (2)

<div class="flex gap-3">

<div class="w-1/2">

- คำสั่งหนึ่งจะมีขนาด 16 bit (2 bytes) และแบ่งออกเป็น 4 ส่วน แต่ละส่วนมีขนาด 4 bit (1 byte) โดย

    - **4 bit ซ้ายสุด:** ใช้สำหรับเก็บ opcode

    - **อีก 12 bit:** ใช้สำหรับเก็บ operand หรือที่อยู่ของ operand

</div>

<div class="w-1/2">

<img src="/images/chapter5/instruction_format_type.png" />
</div>
</div>


---

# Processing the instructions 

- ขั้นตอนการประมวลผลคำสั่ง

    1. ขั้นตอนการดึงคำสั่ง **(Fetch Phase):**

        1. คอมพิวเตอร์จะไปดึงคำสั่งถัดไปมาจากหน่วยความจำ: คำสั่งที่ดึงมานั้นจะถูกกำหนดโดยตัวชี้โปรแกรม **(Program Counter: PC)** ซึ่งเป็นตัวบอกตำแหน่งของคำสั่งถัดไปที่ต้องประมวลผล

        2. คำสั่งที่ดึงมาจะถูกนำไปเก็บไว้ในหน่วยเก็บคำสั่ง **(Instruction Register: IR)** เพื่อเตรียมไว้สำหรับขั้นตอนถัดไป


---

# Processing the instructions (2)

- ขั้นตอนการประมวลผลคำสั่ง

    2. ขั้นตอนการถอดรหัส **(Decode Phase):**

        1. คอมพิวเตอร์จะทำการถอดรหัสคำสั่งที่อยู่ใน **IR:** เพื่อแยกแยะว่าคำสั่งนั้นมีความหมายว่าอะไร และต้องการใช้อะไรในการทำงาน เช่น การบวก ลบ คูณ หาร หรือการย้ายข้อมูล
        
        2. คอมพิวเตอร์จะไปดึงข้อมูลที่จำเป็นมาใช้งาน: ข้อมูลเหล่านี้อาจจะเป็นตัวเลขที่ต้องการนำมาคำนวณ หรือที่อยู่ของข้อมูลในหน่วยความจำ


---

# Processing the instructions (3)


- ขั้นตอนการประมวลผลคำสั่ง

    3. ขั้นตอนการปฏิบัติการ **(Execute Phase):**

        1. คอมพิวเตอร์จะทำตามคำสั่งที่ได้ถอดรหัส: เช่น การทำการคำนวณ การย้ายข้อมูล หรือการเปรียบเทียบค่า

        2. ผลลัพธ์ที่ได้จากการปฏิบัติการจะถูกเก็บไว้ในที่ที่เหมาะสม: เช่น ในหน่วยความจำ หรือในรีจิสเตอร์
    
---

# Processing the instructions (4)

- ขั้นตอนการประมวลผลคำสั่ง

    4. ขั้นตอนสุดท้ายและการเริ่มต้นวงจรใหม่:

        1. หลังจากที่คอมพิวเตอร์ทำการประมวลผลคำสั่งหนึ่งเสร็จสิ้น 
        (ซึ่งประกอบด้วยขั้นตอนการดึงคำสั่ง, ถอดรหัส และปฏิบัติการ) หน่วยควบคุมจะเริ่มต้นวงจรการทำงานใหม่อีกครั้ง

        2. ในการเริ่มต้นวงจรใหม่นี้ ตัวชี้โปรแกรม (PC) ซึ่งทำหน้าที่ชี้ไปยังตำแหน่งของคำสั่งถัดไปในหน่วยความจำ จะถูกปรับให้ชี้ไปที่คำสั่งถัดไปในลำดับของโปรแกรม

- การสิ้นสุดของกระบวนการ:

    1. กระบวนการประมวลผลคำสั่งจะดำเนินต่อไปเรื่อยๆ ตามลำดับของคำสั่งในโปรแกรม
    2. กระบวนการจะสิ้นสุดลงเมื่อ CPU พบคำสั่งพิเศษที่เรียกว่า **HALT** ซึ่งเป็นคำสั่งที่บอกให้ CPU หยุดทำงาน

---

# List of instructions for the simple computer

<div class="flex gap-3">

<div class="w-1/2">

- การอ่านตาราง
    - **Instruction:** ชื่อของคำสั่ง (ภาษาที่คอมพิวเตอร์เข้าใจ)
    - **Code:** รหัสตัวเลขที่แทนคำสั่ง (คอมพิวเตอร์จะเข้าใจรหัสนี้)
    - **Operands:** ข้อมูลเพิ่มเติมที่คำสั่งต้องการ เช่น ตัวเลขที่จะนำมาคำนวณ หรือตำแหน่งหน่วยความจำที่จะไปเอาข้อมูลมา
    - **Action:** คำอธิบายว่าคำสั่งนั้นทำอะไร

</div>

<div class="w-1/2">

<img src="/images/chapter5/list_instruction_table.png" class="w-[350px]" />
</div>
</div>

---

# List of instructions for the simple computer (2)

<div class="flex gap-3">

<div class="w-4/6">

- การอ่านตาราง
    - **Key:**
        - S - Source (ต้นทาง)
        - D - Destination (ปลายทาง)
        - R<sub>S</sub>, R<sub>S1</sub>, R<sub>S2</sub>: Hexadecimal address of source registers
        - R<sub>D</sub>: Hexadecimal address of destination register
        - M<sub>S</sub>, R<sub>S1</sub>, R<sub>S2</sub>: Hexadecimal address of source memory location
        - M<sub>D</sub>, R<sub>S1</sub>, R<sub>S2</sub>: Hexadecimal address of destination memory location
        - ***n***: hexadecimal number
        - d<sub>1</sub>, d<sub>2</sub>, d<sub>3</sub>, d<sub>4</sub>: First, second, third, and fourth hexadecimal digits 

</div>

<div class="w-2/6">

<img src="/images/chapter5/list_instruction_table.png" class="" />
</div>
</div>

---

# List of instructions for the simple computer (3)

<div class="flex gap-3">

<div class="w-1/2">

- ตัวอย่างคำอธิบายคำสั่ง
    1. **HALT:** คำสั่งนี้จะทำให้คอมพิวเตอร์หยุดทำงาน
    2. **LOAD:** คำสั่งนี้จะนำข้อมูลจากหน่วยความจำมาเก็บไว้ในรีจิสเตอร์
    3. **ADD:** คำสั่งนี้จะนำค่าในสองรีจิสเตอร์มาบวกกัน แล้วเก็บผลลัพธ์ไว้ในรีจิสเตอร์อีกตัว


</div>

<div class="w-1/2">

<img src="/images/chapter5/list_instruction_table.png" class="w-[350px]" />
</div>
</div>

---

# List of instructions for the simple computer (4)

<div class="flex gap-3">

<div class="w-1/2">

- ตัวอย่าง

<table class="border">
<thead>
<tr rowspan="2">
<th rowspan="2" class="w-1/5">
<div class="text-center">Instruction</div>
</th>
<th class="border">
<div class="text-center">Code</div>
</th>
<th colspan="4" class="border">
<div class="text-center">Operands</div>
</th>
</tr>
<tr>
<th class="border w-1/5">
<div class="text-center">d1</div>
</th>
<th class="border w-1/5">
<div class="text-center">d2</div>
</th>
<th class="border w-1/5">
<div class="text-center">d3</div>
</th>
<th class="border w-1/5">
<div class="text-center">d4</div>
</th>
</tr>
</thead>

<tbody>
<tr>
<td class="border">LOAD</td>
<td class="border">
<div class="text-center">1</div>
</td>
<td class="border">
<div class="text-center">0</div>
</td>
<td class="border">
<div class="text-center">4</div>
</td>
<td class="border">
<div class="text-center">0</div>
</td>
</tr>
<tr>
<td class="border">LOAD</td>
<td class="border">
<div class="text-center">1</div>
</td>
<td class="border">
<div class="text-center">1</div>
</td>
<td class="border">
<div class="text-center">4</div>
</td>
<td class="border">
<div class="text-center">1</div>
</td>
</tr>
<tr>
<td class="border">ADDI</td>
<td class="border">
<div class="text-center">3</div>
</td>
<td class="border">
<div class="text-center">2</div>
</td>
<td class="border">
<div class="text-center">0</div>
</td>
<td class="border">
<div class="text-center">1</div>
</td>
</tr>
<tr>
<td class="border">STORE</td>
<td class="border">
<div class="text-center">2</div>
</td>
<td class="border">
<div class="text-center">2</div>
</td>
<td class="border">
<div class="text-center">2</div>
</td>
<td class="border">
<div class="text-center">2</div>
</td>
</tr>
<tr>
<td class="border">HALT</td>
<td class="border">
<div class="text-center">0</div>
</td>
<td class="border">
<div class="text-center"></div>
</td>
<td class="border">
<div class="text-center"></div>
</td>
<td class="border">
<div class="text-center"></div>
</td>
</tr>
</tbody>
</table>

</div>

<div class="w-1/2">

<img src="/images/chapter5/list_instruction_table.png" class="w-[350px]" />
</div>
</div>


---

# ตัวอย่าง

- คอมพิวเตอร์สามารถนำจำนวนเต็มสองจำนวน (สมมุติว่าเป็น A และ B) มาบวกกันแล้วเก็บผลลัพธ์ไว้ในตัวแปรใหม่ (สมมุติว่าเป็น C)
จำนวนเต็มที่นำมาคำนวณนั้นอยู่ในรูปแบบ two's complement ซึ่งเป็นวิธีการแทนจำนวนเต็มบวกและลบในคอมพิวเตอร์
    - ค่าของ C จะเท่ากับผลบวกของ A และ B นั่นเอง **C = A + B**

---

# ตัวอย่าง 2

- เราต้องการบวกจำนวนเต็มสองจำนวนที่เก็บไว้ในหน่วยความจำตำแหน่ง (40)<sub>16</sub> และ (41)<sub>16</sub> ผลลัพธ์ของการบวกจะถูกเก็บไว้ในหน่วยความจำตำแหน่ง (42)<sub>16</sub>


<img src="/images/chapter5/example1.png" />

- คำสั่งที่ใช้
    1. นำค่าที่อยู่ในหน่วยความจำตำแหน่ง M<sub>40</sub> มาเก็บไว้ในรีจิสเตอร์ R<sub>0</sub>
    2. นำค่าที่อยู่ในหน่วยความจำตำแหน่ง M<sub>41</sub> มาเก็บไว้ในรีจิสเตอร์ R<sub>1</sub>
    3. นำค่าในรีจิสเตอร์ R<sub>0</sub> และ R<sub>1</sub> มาบวกกัน แล้วเก็บผลลัพธ์ไว้ในรีจิสเตอร์ R<sub>2</sub>
    4. นำค่าในรีจิสเตอร์ R<sub>2</sub> (ซึ่งเป็นผลลัพธ์ของการบวก) ไปเก็บไว้ในหน่วยความจำตำแหน่ง (42)<sub>16</sub>
    5. Halt: หยุดการทำงานของโปรแกรม

---

# ตัวอย่าง 2 (2)

- แปลง 5 คำสั่ง

<table class="border mt-3">
<thead>
<tr>
<th class="border">Code</th>
<th colspan="4">Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="border">
(1040)<sub>16</sub>
</td>
<td class="border">
1: LOAD
</td>
<td class="border">
0: R<sub>0</sub>
</td>
<td colspan="2" class="border">
40: M<sub>40</sub>
</td>
</tr>
<tr>
<td class="border">
(1041)<sub>16</sub>
</td>
<td class="border">
1: LOAD
</td>
<td class="border">
1: R<sub>1</sub>
</td>
<td colspan="2" class="border">
41: M<sub>41</sub>
</td>
</tr>
<tr>
<td class="border">
(3201)<sub>16</sub>
</td>
<td class="border">
3: ADDI
</td>
<td class="border">
2: R<sub>2</sub>
</td>
<td class="border">
0: R<sub>0</sub>
</td>
<td class="border">
1: R<sub>1</sub>
</td>
</tr>
<tr>
<td class="border">
(2422)<sub>16</sub>
</td>
<td class="border">
2: STORE
</td>
<td colspan="2" class="border">
42: M<sub>42</sub>
</td>
<td class="border">
2: R<sub>2</sub>
</td>
</tr>
<tr>
<td class="border">
(000)<sub>16</sub>
</td>
<td class="border">
0: HALT
</td>
<td class="border">
</td>
<td class="border">
</td>
<td class="border">
</td>
</tr>
</tbody>
</table>


---

# ตัวอย่าง 2 (3) 

- **Code:** คือรหัสตัวเลขที่แทนคำสั่งแต่ละคำสั่ง โดยมักจะเขียนในระบบเลขฐานสิบหก (hexadecimal)

- **Interpretation:** คือคำอธิบายความหมายของคำสั่งนั้นเป็นภาษาคน

- การทำงานของแต่ละคำสั่ง
    1. (1040)<sub>16</sub>: คำสั่งนี้แปลว่า "นำค่าในหน่วยความจำตำแหน่ง 40 มาเก็บไว้ในรีจิสเตอร์ R<sub>0</sub>"

    2. (1141)<sub>16</sub>: คำสั่งนี้แปลว่า "นำค่าในหน่วยความจำตำแหน่ง 41 มาเก็บไว้ในรีจิสเตอร์ R<sub>1</sub>"

    3. (3201)<sub>16</sub>: คำสั่งนี้แปลว่า "นำค่าในรีจิสเตอร์ R<sub>0</sub> และ R<sub>1</sub> มาบวกกัน แล้วเก็บผลลัพธ์ไว้ในรีจิสเตอร์ R<sub>2</sub>"

    4. (2422)<sub>16</sub>: คำสั่งนี้แปลว่า "นำค่าในรีจิสเตอร์ R<sub>2</sub> ไปเก็บไว้ในหน่วยความจำตำแหน่ง 42"

    5. (0000)<sub>16</sub>: คำสั่งนี้แปลว่า "หยุดการทำงานของโปรแกรม"

---

# ตัวอย่าง 2 (4) 

- บันทึกโปรแกรมและข้อมูล 

    - บันทึกโปรแกรมทั้ง 5 บรรทัดไว้ที่หน่วยความจำ (00)<sub>16</sub> ถึง (04)<sub>16</sub>

    - บันทึกข้อมูลไว้ที่หน่วยความจำ (40)<sub>16</sub>, (41)<sub>16</sub>, (42)<sub>16</sub>

- รอบการทำงาน
   - การประมวลผลคำสั่งหนึ่งคำสั่งจะใช้เวลาหนึ่งรอบ

   - ถ้าโปรแกรมมี 5 คำสั่ง ก็จะต้องใช้เวลา 5 รอบในการประมวลผลทั้งหมด

   - Add: 161 + 254 = 415, ตัวเลขเหล่านี้ จะถูกเก็บไว้ใน memory ในรูปฐาน 16 นั่นก็คือ (00A1)<sub>16</sub>, (00FE)<sub>16</sub> และ (019F)<sub>16</sub>
    

---
layout: image
image: /images/chapter5/cycle1.png
backgroundSize: contain
---

---
layout: image
image: /images/chapter5/cycle2.png
backgroundSize: contain
---
---
layout: image
image: /images/chapter5/cycle3.png
backgroundSize: contain
---
---
layout: image
image: /images/chapter5/cycle4.png
backgroundSize: contain
---
---
layout: image
image: /images/chapter5/cycle5.png
backgroundSize: contain
---